// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title YieldArbitrageRouter
 * @dev Universal router for executing atomic DeFi operations across multiple protocols
 * 
 * This router can handle all edge types from our yield arbitrage system:
 * - TRADE: Direct swaps on DEXs
 * - SPLIT: Divide funds across multiple operations  
 * - COMBINE: Aggregate funds from multiple sources
 * - LEND/BORROW: Money market operations
 * - STAKE: Staking operations
 * - Flash loans for capital provisioning
 */
contract YieldArbitrageRouter is ReentrancyGuard, Ownable, Pausable {
    using SafeERC20 for IERC20;

    // Events
    event SegmentExecuted(
        bytes32 indexed segmentId,
        address indexed initiator,
        uint256 gasUsed,
        bool success
    );
    
    event FlashLoanExecuted(
        address indexed asset,
        uint256 amount,
        uint256 premium,
        bool success
    );
    
    event EmergencyWithdraw(address indexed token, uint256 amount);

    // Edge operation types matching our Python enum
    enum EdgeType {
        TRADE,
        SPLIT, 
        COMBINE,
        BRIDGE,
        LEND,
        BORROW,
        STAKE,
        WAIT,
        SHORT,
        FLASH_LOAN,
        BACK_RUN
    }

    // Structure for individual edge operations
    struct EdgeOperation {
        EdgeType edgeType;
        address targetContract;   // Protocol contract to call directly
        address inputToken;
        address outputToken;
        uint256 inputAmount;      // 0 for dynamic amounts
        uint256 minOutputAmount;
        bytes callData;           // Raw calldata generated by Python adapters
        bytes metadata;          // Additional operation metadata
    }

    // Structure for executable segments (from our path analyzer)
    struct PathSegment {
        bytes32 segmentId;
        EdgeOperation[] operations;
        bool requiresFlashLoan;
        address flashLoanAsset;
        uint256 flashLoanAmount;
        address recipient;       // Final recipient of segment output
        uint256 deadline;        // Execution deadline
    }

    // Protocol contract registry
    mapping(string => address) public protocolContracts;
    mapping(address => bool) public approvedContracts;
    
    // Flash loan provider integration
    address public flashLoanProvider; // Aave V3 Pool
    
    // Security settings
    uint256 public maxOperationsPerSegment = 20;
    uint256 public maxGasPerOperation = 500_000;
    mapping(address => bool) public approvedCallers;
    
    // Fee settings  
    uint256 public platformFeeBps = 0; // 0 basis points initially
    address public feeRecipient;

    constructor(address _flashLoanProvider) {
        flashLoanProvider = _flashLoanProvider;
        feeRecipient = msg.sender;
        approvedCallers[msg.sender] = true;
    }

    /**
     * @dev Execute a path segment atomically
     * @param segment The segment to execute containing all operations
     */
    function executeSegment(PathSegment calldata segment) 
        external 
        nonReentrant 
        whenNotPaused 
        returns (bool success, uint256 gasUsed) 
    {
        require(approvedCallers[msg.sender], "Unauthorized caller");
        require(segment.operations.length > 0, "Empty segment");
        require(segment.operations.length <= maxOperationsPerSegment, "Too many operations");
        require(block.timestamp <= segment.deadline, "Segment expired");

        uint256 startGas = gasleft();

        if (segment.requiresFlashLoan) {
            success = _executeWithFlashLoan(segment);
        } else {
            success = _executeOperations(segment.operations, segment.recipient);
        }

        gasUsed = startGas - gasleft();

        emit SegmentExecuted(segment.segmentId, msg.sender, gasUsed, success);
        return (success, gasUsed);
    }

    /**
     * @dev Execute operations with flash loan
     */
    function _executeWithFlashLoan(PathSegment calldata segment) 
        internal 
        returns (bool) 
    {
        // Encode segment data for flash loan callback
        bytes memory params = abi.encode(segment);
        
        // Request flash loan from Aave V3
        address[] memory assets = new address[](1);
        assets[0] = segment.flashLoanAsset;
        
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = segment.flashLoanAmount;
        
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0; // No debt mode
        
        IFlashLoanProvider(flashLoanProvider).flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            params,
            0 // referral code
        );
        
        return true; // Flash loan callback will handle actual execution
    }

    /**
     * @dev Execute a sequence of operations atomically
     */
    function _executeOperations(EdgeOperation[] calldata operations, address recipient) 
        internal 
        returns (bool) 
    {
        for (uint256 i = 0; i < operations.length; i++) {
            EdgeOperation calldata op = operations[i];
            
            require(approvedContracts[op.targetContract], "Unapproved contract");
            require(gasleft() > maxGasPerOperation, "Insufficient gas");
            
            bool success = _executeOperation(op, i == operations.length - 1 ? recipient : address(this));
            require(success, "Operation failed");
        }
        
        return true;
    }

    /**
     * @dev Execute a single edge operation
     */
    function _executeOperation(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        // Handle different edge types
        if (op.edgeType == EdgeType.TRADE) {
            return _executeTrade(op, recipient);
        } else if (op.edgeType == EdgeType.SPLIT) {
            return _executeSplit(op, recipient);
        } else if (op.edgeType == EdgeType.COMBINE) {
            return _executeCombine(op, recipient);
        } else if (op.edgeType == EdgeType.LEND) {
            return _executeLend(op, recipient);
        } else if (op.edgeType == EdgeType.BORROW) {
            return _executeBorrow(op, recipient);
        } else if (op.edgeType == EdgeType.STAKE) {
            return _executeStake(op, recipient);
        } else {
            revert("Unsupported edge type");
        }
    }

    /**
     * @dev Execute a trade operation (DEX swap)
     */
    function _executeTrade(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        // Get input amount (dynamic if 0)
        uint256 inputAmount = op.inputAmount;
        if (inputAmount == 0) {
            inputAmount = IERC20(op.inputToken).balanceOf(address(this));
        }
        
        require(inputAmount > 0, "No input amount");
        
        // Approve protocol contract to spend tokens
        IERC20(op.inputToken).safeApprove(op.targetContract, inputAmount);
        
        // Record output balance before
        uint256 balanceBefore = IERC20(op.outputToken).balanceOf(recipient);
        
        // Execute raw calldata generated by Python adapter
        (bool success, ) = op.targetContract.call(op.callData);
        require(success, "Protocol call failed");
        
        // Verify minimum output
        uint256 balanceAfter = IERC20(op.outputToken).balanceOf(recipient);
        uint256 outputAmount = balanceAfter - balanceBefore;
        require(outputAmount >= op.minOutputAmount, "Insufficient output");
        
        return true;
    }

    /**
     * @dev Execute a split operation (divide funds)
     */
    function _executeSplit(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        // Split operations divide current token balance according to metadata
        uint256 totalAmount = IERC20(op.inputToken).balanceOf(address(this));
        
        // Decode split percentages from metadata
        uint256[] memory percentages = abi.decode(op.metadata, (uint256[]));
        
        require(percentages.length > 0, "No split percentages");
        
        uint256 totalPercentage = 0;
        for (uint256 i = 0; i < percentages.length; i++) {
            totalPercentage += percentages[i];
        }
        require(totalPercentage == 10000, "Percentages must sum to 100%"); // 10000 = 100.00%
        
        // Transfer split amounts (implementation depends on specific use case)
        // For now, just ensure we don't lose funds
        return true;
    }

    /**
     * @dev Execute a combine operation (aggregate funds)
     */
    function _executeCombine(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        // Combine operations aggregate multiple token balances
        // Implementation depends on specific combining logic
        return true;
    }

    /**
     * @dev Execute a lending operation
     */
    function _executeLend(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        // Similar to trade but for lending protocols (Aave, Compound)
        uint256 inputAmount = op.inputAmount;
        if (inputAmount == 0) {
            inputAmount = IERC20(op.inputToken).balanceOf(address(this));
        }
        
        IERC20(op.inputToken).safeApprove(op.targetContract, inputAmount);
        
        (bool success, ) = op.targetContract.call(op.callData);
        require(success, "Lending call failed");
        
        return true;
    }

    /**
     * @dev Execute a borrowing operation
     */
    function _executeBorrow(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        (bool success, ) = op.targetContract.call(op.callData);
        require(success, "Borrowing call failed");
        
        return true;
    }

    /**
     * @dev Execute a staking operation
     */
    function _executeStake(EdgeOperation calldata op, address recipient) 
        internal 
        returns (bool) 
    {
        uint256 inputAmount = op.inputAmount;
        if (inputAmount == 0) {
            inputAmount = IERC20(op.inputToken).balanceOf(address(this));
        }
        
        IERC20(op.inputToken).safeApprove(op.targetContract, inputAmount);
        
        (bool success, ) = op.targetContract.call(op.callData);
        require(success, "Staking call failed");
        
        return true;
    }

    /**
     * @dev Flash loan callback for Aave V3
     */
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        require(msg.sender == flashLoanProvider, "Invalid flash loan caller");
        require(initiator == address(this), "Invalid initiator");

        // Decode segment from params
        PathSegment memory segment = abi.decode(params, (PathSegment));
        
        // Execute the operations with borrowed funds
        bool success = _executeOperations(segment.operations, segment.recipient);
        require(success, "Flash loan operations failed");
        
        // Ensure we can repay the loan
        uint256 amountOwing = amounts[0] + premiums[0];
        require(
            IERC20(assets[0]).balanceOf(address(this)) >= amountOwing,
            "Insufficient funds to repay flash loan"
        );
        
        // Approve flash loan provider to pull repayment
        IERC20(assets[0]).safeApprove(flashLoanProvider, amountOwing);
        
        emit FlashLoanExecuted(assets[0], amounts[0], premiums[0], true);
        
        return true;
    }

    // Administrative functions

    /**
     * @dev Register a protocol contract
     */
    function registerProtocol(string calldata protocolName, address contractAddress) 
        external 
        onlyOwner 
    {
        require(contractAddress != address(0), "Invalid contract");
        protocolContracts[protocolName] = contractAddress;
        approvedContracts[contractAddress] = true;
    }

    /**
     * @dev Approve/revoke caller permissions
     */
    function setCallerApproval(address caller, bool approved) 
        external 
        onlyOwner 
    {
        approvedCallers[caller] = approved;
    }

    /**
     * @dev Update security settings
     */
    function updateSecuritySettings(
        uint256 _maxOperationsPerSegment,
        uint256 _maxGasPerOperation
    ) external onlyOwner {
        maxOperationsPerSegment = _maxOperationsPerSegment;
        maxGasPerOperation = _maxGasPerOperation;
    }

    /**
     * @dev Emergency pause
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpause
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Emergency token recovery
     */
    function emergencyWithdraw(address token, uint256 amount) 
        external 
        onlyOwner 
    {
        IERC20(token).safeTransfer(owner(), amount);
        emit EmergencyWithdraw(token, amount);
    }

    /**
     * @dev Update flash loan provider
     */
    function updateFlashLoanProvider(address newProvider) 
        external 
        onlyOwner 
    {
        flashLoanProvider = newProvider;
    }

    // View functions

    /**
     * @dev Get registered contract for protocol
     */
    function getProtocolContract(string calldata protocolName) 
        external 
        view 
        returns (address) 
    {
        return protocolContracts[protocolName];
    }

    /**
     * @dev Check if caller is approved
     */
    function isApprovedCaller(address caller) 
        external 
        view 
        returns (bool) 
    {
        return approvedCallers[caller];
    }
}

/**
 * @title IFlashLoanProvider
 * @dev Interface for Aave V3 flash loan provider
 */
interface IFlashLoanProvider {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}
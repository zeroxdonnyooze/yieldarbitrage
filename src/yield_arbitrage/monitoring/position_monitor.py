"""
Robust Position Monitor for Different Position Types.

This module provides comprehensive monitoring for various types of positions including
yield farming, lending/borrowing, liquidity provision, and arbitrage positions.
Each position type has specialized monitoring logic and risk thresholds.
"""
import asyncio
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set, Tuple, Union
from decimal import Decimal
from enum import Enum
from datetime import datetime, timezone, timedelta

from ..risk.delta_tracker import DeltaTracker, DeltaPosition, AssetExposure
from ..execution.asset_oracle import AssetOracleBase
from ..database.execution_logger import get_execution_logger

logger = logging.getLogger(__name__)


class PositionType(str, Enum):
    """Types of positions that can be monitored."""
    ARBITRAGE = "arbitrage"              # Short-term arbitrage positions
    YIELD_FARMING = "yield_farming"      # LP tokens and yield farming
    LENDING = "lending"                  # Lending protocol positions
    BORROWING = "borrowing"              # Debt positions
    LIQUIDITY_PROVISION = "liquidity_provision"  # AMM LP positions
    STAKING = "staking"                  # Staking positions
    FLASH_LOAN = "flash_loan"            # Active flash loan positions
    BRIDGE = "bridge"                    # Cross-chain bridge positions
    SYNTHETIC = "synthetic"              # Synthetic asset positions
    PRINCIPAL_YIELD = "principal_yield"  # pT/yT positions (Pendle-like protocols)


class RiskLevel(str, Enum):
    """Risk levels for positions."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertSeverity(str, Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class PositionAlert:
    """Alert generated by position monitoring."""
    position_id: str
    position_type: PositionType
    alert_type: str
    severity: AlertSeverity
    message: str
    details: Dict[str, Any]
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    is_actionable: bool = True
    recommended_action: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert alert to dictionary."""
        return {
            "position_id": self.position_id,
            "position_type": self.position_type.value,
            "alert_type": self.alert_type,
            "severity": self.severity.value,
            "message": self.message,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
            "is_actionable": self.is_actionable,
            "recommended_action": self.recommended_action
        }


@dataclass
class MonitoringConfig:
    """Configuration for position monitoring."""
    # Check intervals (seconds)
    check_interval_seconds: int = 30
    high_frequency_interval_seconds: int = 5
    daily_health_check_interval: int = 86400  # 24 hours
    
    # Risk thresholds
    max_unrealized_loss_percent: float = 15.0  # 15% max loss
    liquidation_threshold_buffer: float = 0.05  # 5% buffer above liquidation
    impermanent_loss_threshold: float = 5.0    # 5% IL warning
    yield_rate_deviation_threshold: float = 50.0  # 50% yield rate change
    
    # Position size limits
    max_position_size_usd: float = 100000.0
    max_total_exposure_usd: float = 500000.0
    
    # Health check parameters
    min_health_factor: float = 1.5  # For lending positions
    max_utilization_rate: float = 0.85  # 85% max utilization
    
    # Principal/Yield Token specific thresholds
    maturity_warning_days: int = 7       # Warn X days before maturity
    maturity_critical_days: int = 1      # Critical alert X days before maturity
    time_decay_threshold: float = 0.15   # 15% time decay warning
    yield_rate_deviation_threshold_pt: float = 30.0  # 30% yield rate change for pT
    implied_yield_deviation_threshold: float = 25.0  # 25% implied yield change
    
    # Alert configuration
    alert_cooldown_seconds: int = 300  # 5 minutes between same alerts
    critical_alert_immediate: bool = True
    enable_automated_responses: bool = False


@dataclass
class PositionHealth:
    """Health assessment for a position."""
    position_id: str
    position_type: PositionType
    overall_health: RiskLevel
    health_score: float  # 0-1 scale
    
    # Metrics
    unrealized_pnl_usd: Decimal
    unrealized_pnl_percent: float
    current_value_usd: Decimal
    initial_value_usd: Decimal
    
    # Risk factors
    liquidation_risk: float  # 0-1 scale
    impermanent_loss: Optional[float] = None
    yield_rate_current: Optional[float] = None
    yield_rate_expected: Optional[float] = None
    
    # Additional metrics by position type
    health_factor: Optional[float] = None  # For lending
    utilization_rate: Optional[float] = None  # For borrowing
    apr_deviation: Optional[float] = None  # For yield farming
    
    # Timestamps
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert health to dictionary."""
        return {
            "position_id": self.position_id,
            "position_type": self.position_type.value,
            "overall_health": self.overall_health.value,
            "health_score": self.health_score,
            "unrealized_pnl_usd": float(self.unrealized_pnl_usd),
            "unrealized_pnl_percent": self.unrealized_pnl_percent,
            "current_value_usd": float(self.current_value_usd),
            "liquidation_risk": self.liquidation_risk,
            "impermanent_loss": self.impermanent_loss,
            "health_factor": self.health_factor,
            "last_updated": self.last_updated.isoformat()
        }


class PositionMonitorBase(ABC):
    """Base class for position-specific monitors."""
    
    def __init__(
        self,
        position_type: PositionType,
        asset_oracle: AssetOracleBase,
        config: MonitoringConfig
    ):
        self.position_type = position_type
        self.asset_oracle = asset_oracle
        self.config = config
        
        # Alert management
        self.recent_alerts: Dict[str, datetime] = {}
        
    @abstractmethod
    async def check_position_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> PositionHealth:
        """Check health of a specific position."""
        pass
    
    @abstractmethod
    async def generate_alerts(
        self,
        position: DeltaPosition,
        health: PositionHealth
    ) -> List[PositionAlert]:
        """Generate alerts based on position health."""
        pass
    
    def should_send_alert(self, alert_key: str) -> bool:
        """Check if alert should be sent based on cooldown."""
        now = datetime.now(timezone.utc)
        if alert_key in self.recent_alerts:
            time_since_last = (now - self.recent_alerts[alert_key]).total_seconds()
            if time_since_last < self.config.alert_cooldown_seconds:
                return False
        
        self.recent_alerts[alert_key] = now
        return True
    
    async def calculate_base_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> Tuple[Decimal, Decimal, float]:
        """Calculate base health metrics common to all position types."""
        current_value = Decimal('0')
        initial_value = Decimal('0')
        
        for asset_id, exposure in position.exposures.items():
            current_price = current_prices.get(asset_id, 1.0)
            current_value += abs(exposure.amount) * Decimal(str(current_price))
            
            # Estimate initial value (simplified)
            initial_value += abs(exposure.amount) * Decimal(str(current_price))
        
        if initial_value > 0:
            unrealized_pnl = current_value - initial_value
            unrealized_pnl_percent = float((unrealized_pnl / initial_value) * 100)
        else:
            unrealized_pnl = Decimal('0')
            unrealized_pnl_percent = 0.0
        
        return current_value, unrealized_pnl, unrealized_pnl_percent


class ArbitragePositionMonitor(PositionMonitorBase):
    """Monitor for short-term arbitrage positions."""
    
    def __init__(self, asset_oracle: AssetOracleBase, config: MonitoringConfig):
        super().__init__(PositionType.ARBITRAGE, asset_oracle, config)
    
    async def check_position_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> PositionHealth:
        """Check arbitrage position health - focused on execution speed and slippage."""
        current_value, unrealized_pnl, unrealized_pnl_percent = await self.calculate_base_health(
            position, current_prices
        )
        
        # Arbitrage positions should complete quickly
        position_age = time.time() - position.entry_time
        
        # Calculate health score based on PnL and time
        health_score = 1.0
        if unrealized_pnl_percent < -5:  # More than 5% loss is concerning for arbitrage
            health_score *= 0.5
        if position_age > 300:  # More than 5 minutes is too long for arbitrage
            health_score *= 0.7
        
        # Determine overall health
        if health_score > 0.8:
            overall_health = RiskLevel.LOW
        elif health_score > 0.6:
            overall_health = RiskLevel.MEDIUM
        elif health_score > 0.3:
            overall_health = RiskLevel.HIGH
        else:
            overall_health = RiskLevel.CRITICAL
        
        return PositionHealth(
            position_id=position.position_id,
            position_type=self.position_type,
            overall_health=overall_health,
            health_score=health_score,
            unrealized_pnl_usd=unrealized_pnl,
            unrealized_pnl_percent=unrealized_pnl_percent,
            current_value_usd=current_value,
            initial_value_usd=current_value - unrealized_pnl,
            liquidation_risk=0.0  # Arbitrage positions typically don't have liquidation risk
        )
    
    async def generate_alerts(
        self,
        position: DeltaPosition,
        health: PositionHealth
    ) -> List[PositionAlert]:
        """Generate alerts for arbitrage positions."""
        alerts = []
        position_age = time.time() - position.entry_time
        
        # Alert for stuck arbitrage
        if position_age > 600:  # 10 minutes
            alert_key = f"{position.position_id}_stuck"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="execution_timeout",
                    severity=AlertSeverity.ERROR,
                    message=f"Arbitrage position stuck for {position_age/60:.1f} minutes",
                    details={"position_age_seconds": position_age},
                    recommended_action="Investigate execution status and consider manual intervention"
                ))
        
        # Alert for significant loss
        if health.unrealized_pnl_percent < -10:
            alert_key = f"{position.position_id}_loss"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="unrealized_loss",
                    severity=AlertSeverity.WARNING,
                    message=f"Arbitrage position showing {health.unrealized_pnl_percent:.1f}% loss",
                    details={"unrealized_pnl_percent": health.unrealized_pnl_percent},
                    recommended_action="Review arbitrage logic and market conditions"
                ))
        
        return alerts


class YieldFarmingPositionMonitor(PositionMonitorBase):
    """Monitor for yield farming and LP positions."""
    
    def __init__(self, asset_oracle: AssetOracleBase, config: MonitoringConfig):
        super().__init__(PositionType.YIELD_FARMING, asset_oracle, config)
    
    async def check_position_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> PositionHealth:
        """Check yield farming position health - focused on IL and yield rates."""
        current_value, unrealized_pnl, unrealized_pnl_percent = await self.calculate_base_health(
            position, current_prices
        )
        
        # Calculate impermanent loss (simplified estimation)
        impermanent_loss = await self._estimate_impermanent_loss(position, current_prices)
        
        # Estimate current yield rate (mock for now)
        current_yield_rate = await self._estimate_yield_rate(position)
        expected_yield_rate = 5.0  # 5% APR expected (would come from position metadata)
        
        # Calculate health score
        health_score = 1.0
        
        # Penalize for high impermanent loss
        if impermanent_loss and impermanent_loss > 10:
            health_score *= 0.6
        elif impermanent_loss and impermanent_loss > 5:
            health_score *= 0.8
        
        # Penalize for poor yield performance
        if current_yield_rate and expected_yield_rate:
            yield_ratio = current_yield_rate / expected_yield_rate
            if yield_ratio < 0.5:  # Yield dropped by 50%+
                health_score *= 0.7
        
        # Overall unrealized PnL impact
        if unrealized_pnl_percent < -15:
            health_score *= 0.4
        elif unrealized_pnl_percent < -5:
            health_score *= 0.8
        
        # Determine overall health
        if health_score > 0.8:
            overall_health = RiskLevel.LOW
        elif health_score > 0.6:
            overall_health = RiskLevel.MEDIUM
        elif health_score > 0.3:
            overall_health = RiskLevel.HIGH
        else:
            overall_health = RiskLevel.CRITICAL
        
        return PositionHealth(
            position_id=position.position_id,
            position_type=self.position_type,
            overall_health=overall_health,
            health_score=health_score,
            unrealized_pnl_usd=unrealized_pnl,
            unrealized_pnl_percent=unrealized_pnl_percent,
            current_value_usd=current_value,
            initial_value_usd=current_value - unrealized_pnl,
            liquidation_risk=0.0,  # LP positions typically don't liquidate
            impermanent_loss=impermanent_loss,
            yield_rate_current=current_yield_rate,
            yield_rate_expected=expected_yield_rate
        )
    
    async def _estimate_impermanent_loss(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> Optional[float]:
        """Estimate impermanent loss for LP positions."""
        # Simplified IL calculation - in production would need actual LP token data
        # This is a placeholder that estimates IL based on price changes
        
        if len(position.exposures) != 2:
            return None  # Not a typical LP pair
        
        assets = list(position.exposures.keys())
        if len(assets) < 2:
            return None
        
        # Mock IL calculation - would need historical entry prices
        # For now, return a small random IL for demonstration
        import random
        return random.uniform(0.5, 3.0)  # 0.5% to 3% IL
    
    async def _estimate_yield_rate(self, position: DeltaPosition) -> Optional[float]:
        """Estimate current yield rate for the position."""
        # Mock yield rate - in production would query the actual protocol
        import random
        return random.uniform(3.0, 8.0)  # 3% to 8% APR
    
    async def generate_alerts(
        self,
        position: DeltaPosition,
        health: PositionHealth
    ) -> List[PositionAlert]:
        """Generate alerts for yield farming positions."""
        alerts = []
        
        # High impermanent loss alert
        if health.impermanent_loss and health.impermanent_loss > self.config.impermanent_loss_threshold:
            alert_key = f"{position.position_id}_il"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="impermanent_loss",
                    severity=AlertSeverity.WARNING,
                    message=f"High impermanent loss: {health.impermanent_loss:.1f}%",
                    details={"impermanent_loss": health.impermanent_loss},
                    recommended_action="Consider exiting position if IL exceeds expected yield"
                ))
        
        # Yield rate deviation alert
        if (health.yield_rate_current and health.yield_rate_expected and
            abs(health.yield_rate_current - health.yield_rate_expected) / health.yield_rate_expected > 0.5):
            alert_key = f"{position.position_id}_yield"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="yield_deviation",
                    severity=AlertSeverity.INFO,
                    message=f"Yield rate changed: {health.yield_rate_current:.1f}% vs expected {health.yield_rate_expected:.1f}%",
                    details={
                        "current_yield": health.yield_rate_current,
                        "expected_yield": health.yield_rate_expected
                    },
                    recommended_action="Review yield farming strategy and consider rebalancing"
                ))
        
        return alerts


class LendingPositionMonitor(PositionMonitorBase):
    """Monitor for lending protocol positions."""
    
    def __init__(self, asset_oracle: AssetOracleBase, config: MonitoringConfig):
        super().__init__(PositionType.LENDING, asset_oracle, config)
    
    async def check_position_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> PositionHealth:
        """Check lending position health - focused on utilization and rates."""
        current_value, unrealized_pnl, unrealized_pnl_percent = await self.calculate_base_health(
            position, current_prices
        )
        
        # Mock utilization rate (would query lending protocol)
        utilization_rate = await self._get_utilization_rate(position)
        current_yield_rate = await self._get_lending_rate(position)
        expected_yield_rate = 3.5  # Expected lending rate
        
        # Calculate health score
        health_score = 1.0
        
        # High utilization reduces liquidity
        if utilization_rate > 0.9:
            health_score *= 0.6
        elif utilization_rate > 0.8:
            health_score *= 0.8
        
        # Poor yield performance
        if current_yield_rate and expected_yield_rate:
            if current_yield_rate < expected_yield_rate * 0.7:
                health_score *= 0.8
        
        # Determine overall health
        if health_score > 0.8:
            overall_health = RiskLevel.LOW
        elif health_score > 0.6:
            overall_health = RiskLevel.MEDIUM
        elif health_score > 0.3:
            overall_health = RiskLevel.HIGH
        else:
            overall_health = RiskLevel.CRITICAL
        
        return PositionHealth(
            position_id=position.position_id,
            position_type=self.position_type,
            overall_health=overall_health,
            health_score=health_score,
            unrealized_pnl_usd=unrealized_pnl,
            unrealized_pnl_percent=unrealized_pnl_percent,
            current_value_usd=current_value,
            initial_value_usd=current_value - unrealized_pnl,
            liquidation_risk=0.0,  # Lending positions don't get liquidated
            utilization_rate=utilization_rate,
            yield_rate_current=current_yield_rate,
            yield_rate_expected=expected_yield_rate
        )
    
    async def _get_utilization_rate(self, position: DeltaPosition) -> float:
        """Get utilization rate for lending position."""
        # Mock - would query actual lending protocol
        import random
        return random.uniform(0.4, 0.95)
    
    async def _get_lending_rate(self, position: DeltaPosition) -> float:
        """Get current lending rate."""
        # Mock - would query actual lending protocol
        import random
        return random.uniform(2.0, 6.0)
    
    async def generate_alerts(
        self,
        position: DeltaPosition,
        health: PositionHealth
    ) -> List[PositionAlert]:
        """Generate alerts for lending positions."""
        alerts = []
        
        # High utilization alert
        if health.utilization_rate and health.utilization_rate > self.config.max_utilization_rate:
            alert_key = f"{position.position_id}_utilization"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="high_utilization",
                    severity=AlertSeverity.WARNING,
                    message=f"High utilization rate: {health.utilization_rate:.1%}",
                    details={"utilization_rate": health.utilization_rate},
                    recommended_action="Monitor for liquidity issues, consider partial withdrawal"
                ))
        
        return alerts


class BorrowingPositionMonitor(PositionMonitorBase):
    """Monitor for borrowing/debt positions."""
    
    def __init__(self, asset_oracle: AssetOracleBase, config: MonitoringConfig):
        super().__init__(PositionType.BORROWING, asset_oracle, config)
    
    async def check_position_health(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> PositionHealth:
        """Check borrowing position health - focused on liquidation risk."""
        current_value, unrealized_pnl, unrealized_pnl_percent = await self.calculate_base_health(
            position, current_prices
        )
        
        # Calculate health factor (collateral / debt ratio)
        health_factor = await self._calculate_health_factor(position, current_prices)
        
        # Calculate liquidation risk
        liquidation_risk = max(0.0, 1.0 - (health_factor - 1.0) / 0.5) if health_factor else 0.0
        
        # Calculate health score based on health factor
        health_score = 1.0
        if health_factor < 1.2:
            health_score = 0.1  # Critical
        elif health_factor < 1.5:
            health_score = 0.4  # High risk
        elif health_factor < 2.0:
            health_score = 0.7  # Medium risk
        else:
            health_score = 1.0  # Low risk
        
        # Determine overall health
        if health_score > 0.8:
            overall_health = RiskLevel.LOW
        elif health_score > 0.6:
            overall_health = RiskLevel.MEDIUM
        elif health_score > 0.3:
            overall_health = RiskLevel.HIGH
        else:
            overall_health = RiskLevel.CRITICAL
        
        return PositionHealth(
            position_id=position.position_id,
            position_type=self.position_type,
            overall_health=overall_health,
            health_score=health_score,
            unrealized_pnl_usd=unrealized_pnl,
            unrealized_pnl_percent=unrealized_pnl_percent,
            current_value_usd=current_value,
            initial_value_usd=current_value - unrealized_pnl,
            liquidation_risk=liquidation_risk,
            health_factor=health_factor
        )
    
    async def _calculate_health_factor(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> float:
        """Calculate health factor for borrowing position."""
        # Simplified health factor calculation
        # In production, would query actual lending protocol for precise calculation
        
        total_collateral_value = Decimal('0')
        total_debt_value = Decimal('0')
        
        for asset_id, exposure in position.exposures.items():
            current_price = current_prices.get(asset_id, 1.0)
            asset_value = abs(exposure.amount) * Decimal(str(current_price))
            
            if exposure.exposure_type.value == "long":
                total_collateral_value += asset_value
            elif exposure.exposure_type.value == "short":
                total_debt_value += asset_value
        
        if total_debt_value > 0:
            return float(total_collateral_value / total_debt_value)
        else:
            return float('inf')  # No debt
    
    async def generate_alerts(
        self,
        position: DeltaPosition,
        health: PositionHealth
    ) -> List[PositionAlert]:
        """Generate alerts for borrowing positions."""
        alerts = []
        
        # Liquidation risk alert
        if health.health_factor and health.health_factor < self.config.min_health_factor:
            severity = AlertSeverity.CRITICAL if health.health_factor < 1.2 else AlertSeverity.WARNING
            alert_key = f"{position.position_id}_liquidation"
            if self.should_send_alert(alert_key):
                alerts.append(PositionAlert(
                    position_id=position.position_id,
                    position_type=self.position_type,
                    alert_type="liquidation_risk",
                    severity=severity,
                    message=f"Low health factor: {health.health_factor:.2f}",
                    details={
                        "health_factor": health.health_factor,
                        "liquidation_risk": health.liquidation_risk
                    },
                    recommended_action="Add collateral or repay debt immediately to avoid liquidation"
                ))
        
        return alerts


class PrincipalYieldPositionMonitor(PositionMonitorBase):
    """
    Monitor for Principal Token (pT) and Yield Token (yT) positions on Pendle-like protocols.
    
    These positions have unique risks around:
    - Maturity dates (time to expiration)
    - Yield rate changes and implied yields
    - Time decay (theta) as maturity approaches
    - Principal vs yield token exposure imbalances
    """
    
    def __init__(self, config: MonitoringConfig, asset_oracle: AssetOracleBase):
        super().__init__(config, asset_oracle)
        self.position_type = PositionType.PRINCIPAL_YIELD
    
    async def check_position_health(self, position) -> List[PositionAlert]:
        """Check health of pT/yT positions with focus on maturity and yield risks."""
        alerts = []
        
        try:
            # Extract position metadata
            metadata = getattr(position, 'metadata', {})
            
            # Get position details
            maturity_date = metadata.get('maturity_date')
            position_side = metadata.get('position_side')  # 'principal', 'yield', or 'both'
            underlying_asset = metadata.get('underlying_asset')
            initial_implied_yield = metadata.get('initial_implied_yield')
            current_implied_yield = metadata.get('current_implied_yield')
            
            # Calculate time to maturity
            if maturity_date:
                if isinstance(maturity_date, str):
                    maturity_date = datetime.fromisoformat(maturity_date.replace('Z', '+00:00'))
                elif isinstance(maturity_date, (int, float)):
                    maturity_date = datetime.fromtimestamp(maturity_date, tz=timezone.utc)
                
                days_to_maturity = (maturity_date - datetime.now(timezone.utc)).days
                hours_to_maturity = (maturity_date - datetime.now(timezone.utc)).total_seconds() / 3600
                
                # Maturity warnings
                maturity_alerts = await self._check_maturity_risk(
                    position, days_to_maturity, hours_to_maturity
                )
                alerts.extend(maturity_alerts)
                
                # Time decay analysis
                time_decay_alerts = await self._check_time_decay(
                    position, days_to_maturity, metadata
                )
                alerts.extend(time_decay_alerts)
            
            # Yield rate analysis
            if initial_implied_yield and current_implied_yield:
                yield_alerts = await self._check_yield_deviation(
                    position, initial_implied_yield, current_implied_yield
                )
                alerts.extend(yield_alerts)
            
            # Principal/Yield token balance analysis
            if position_side == 'both':
                balance_alerts = await self._check_pt_yt_balance(position, metadata)
                alerts.extend(balance_alerts)
            
            # Underlying asset exposure analysis
            if underlying_asset:
                exposure_alerts = await self._check_underlying_exposure(
                    position, underlying_asset, metadata
                )
                alerts.extend(exposure_alerts)
            
        except Exception as e:
            logger.error(f"Error checking pT/yT position health for {position.position_id}: {e}")
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="monitoring_error",
                severity=AlertSeverity.WARNING,
                message=f"Failed to monitor position: {str(e)}",
                details={"error": str(e)},
                is_actionable=False
            ))
        
        return alerts
    
    async def _check_maturity_risk(
        self, 
        position, 
        days_to_maturity: int, 
        hours_to_maturity: float
    ) -> List[PositionAlert]:
        """Check for maturity-related risks."""
        alerts = []
        
        # Critical: Very close to maturity
        if days_to_maturity <= self.config.maturity_critical_days:
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="maturity_critical",
                severity=AlertSeverity.CRITICAL,
                message=f"Position expires in {hours_to_maturity:.1f} hours",
                details={
                    "days_to_maturity": days_to_maturity,
                    "hours_to_maturity": hours_to_maturity,
                    "maturity_critical_threshold": self.config.maturity_critical_days
                },
                recommended_action="URGENT: Close position or prepare for settlement immediately"
            ))
        
        # Warning: Approaching maturity
        elif days_to_maturity <= self.config.maturity_warning_days:
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="maturity_warning",
                severity=AlertSeverity.WARNING,
                message=f"Position expires in {days_to_maturity} days",
                details={
                    "days_to_maturity": days_to_maturity,
                    "hours_to_maturity": hours_to_maturity,
                    "maturity_warning_threshold": self.config.maturity_warning_days
                },
                recommended_action="Consider closing position or preparing for maturity settlement"
            ))
        
        # Info: Maturity timeline update
        elif days_to_maturity <= 30:  # Monthly updates for positions <30 days
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="maturity_info",
                severity=AlertSeverity.INFO,
                message=f"Position matures in {days_to_maturity} days",
                details={
                    "days_to_maturity": days_to_maturity,
                    "maturity_category": "medium_term" if days_to_maturity > 14 else "short_term"
                },
                is_actionable=False
            ))
        
        return alerts
    
    async def _check_time_decay(
        self, 
        position, 
        days_to_maturity: int, 
        metadata: Dict[str, Any]
    ) -> List[PositionAlert]:
        """Check for time decay (theta) effects on position value."""
        alerts = []
        
        try:
            # Calculate time decay rate based on position type and maturity
            position_side = metadata.get('position_side', 'both')
            initial_time_to_maturity = metadata.get('initial_days_to_maturity', 365)
            
            if initial_time_to_maturity > 0:
                time_elapsed_ratio = 1 - (days_to_maturity / initial_time_to_maturity)
                
                # Estimate time decay impact (simplified model)
                if position_side in ['yield', 'both']:
                    # Yield tokens experience more time decay
                    estimated_decay = time_elapsed_ratio * 0.3  # Up to 30% decay
                else:
                    # Principal tokens less affected by time decay
                    estimated_decay = time_elapsed_ratio * 0.1  # Up to 10% decay
                
                if estimated_decay > self.config.time_decay_threshold:
                    severity = (AlertSeverity.WARNING if estimated_decay < 0.25 
                              else AlertSeverity.ERROR)
                    
                    alerts.append(PositionAlert(
                        position_id=position.position_id,
                        position_type=self.position_type,
                        alert_type="time_decay",
                        severity=severity,
                        message=f"Significant time decay: {estimated_decay:.1%}",
                        details={
                            "estimated_time_decay": estimated_decay,
                            "time_elapsed_ratio": time_elapsed_ratio,
                            "days_to_maturity": days_to_maturity,
                            "position_side": position_side,
                            "decay_threshold": self.config.time_decay_threshold
                        },
                        recommended_action=(
                            "Consider closing position to avoid further time decay" 
                            if estimated_decay > 0.2 else
                            "Monitor time decay closely as maturity approaches"
                        )
                    ))
        
        except Exception as e:
            logger.warning(f"Failed to calculate time decay for {position.position_id}: {e}")
        
        return alerts
    
    async def _check_yield_deviation(
        self, 
        position, 
        initial_yield: float, 
        current_yield: float
    ) -> List[PositionAlert]:
        """Check for significant changes in implied yield rates."""
        alerts = []
        
        yield_change_percent = ((current_yield - initial_yield) / initial_yield) * 100
        abs_yield_change = abs(yield_change_percent)
        
        if abs_yield_change > self.config.implied_yield_deviation_threshold:
            # Determine if this is good or bad based on position side
            metadata = getattr(position, 'metadata', {})
            position_side = metadata.get('position_side', 'both')
            
            is_favorable = False
            if position_side == 'principal' and yield_change_percent > 0:
                is_favorable = True  # Higher yields favor principal tokens
            elif position_side == 'yield' and yield_change_percent < 0:
                is_favorable = True  # Lower yields favor yield tokens
            
            severity = (AlertSeverity.INFO if is_favorable 
                       else AlertSeverity.WARNING if abs_yield_change < 50
                       else AlertSeverity.ERROR)
            
            direction = "increased" if yield_change_percent > 0 else "decreased"
            impact = "favorable" if is_favorable else "unfavorable"
            
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="yield_deviation",
                severity=severity,
                message=f"Implied yield {direction} by {abs_yield_change:.1f}% ({impact})",
                details={
                    "initial_yield": initial_yield,
                    "current_yield": current_yield,
                    "yield_change_percent": yield_change_percent,
                    "position_side": position_side,
                    "is_favorable": is_favorable,
                    "threshold": self.config.implied_yield_deviation_threshold
                },
                recommended_action=(
                    "Consider rebalancing position based on yield environment changes" 
                    if not is_favorable else
                    "Monitor for profit-taking opportunities"
                )
            ))
        
        return alerts
    
    async def _check_pt_yt_balance(
        self, 
        position, 
        metadata: Dict[str, Any]
    ) -> List[PositionAlert]:
        """Check balance between principal and yield token exposures."""
        alerts = []
        
        try:
            pt_amount = metadata.get('pt_amount', 0)
            yt_amount = metadata.get('yt_amount', 0)
            target_ratio = metadata.get('target_pt_yt_ratio', 1.0)  # 1:1 by default
            
            if pt_amount > 0 and yt_amount > 0:
                current_ratio = pt_amount / yt_amount
                ratio_deviation = abs(current_ratio - target_ratio) / target_ratio
                
                if ratio_deviation > 0.15:  # 15% deviation threshold
                    severity = (AlertSeverity.WARNING if ratio_deviation < 0.3 
                              else AlertSeverity.ERROR)
                    
                    which_side = "principal" if current_ratio > target_ratio else "yield"
                    
                    alerts.append(PositionAlert(
                        position_id=position.position_id,
                        position_type=self.position_type,
                        alert_type="pt_yt_imbalance",
                        severity=severity,
                        message=f"pT/yT ratio imbalance: {current_ratio:.2f} (target: {target_ratio:.2f})",
                        details={
                            "pt_amount": pt_amount,
                            "yt_amount": yt_amount,
                            "current_ratio": current_ratio,
                            "target_ratio": target_ratio,
                            "ratio_deviation": ratio_deviation,
                            "excess_side": which_side
                        },
                        recommended_action=f"Rebalance by adjusting {which_side} token exposure"
                    ))
        
        except Exception as e:
            logger.warning(f"Failed to check pT/yT balance for {position.position_id}: {e}")
        
        return alerts
    
    async def _check_underlying_exposure(
        self, 
        position, 
        underlying_asset: str, 
        metadata: Dict[str, Any]
    ) -> List[PositionAlert]:
        """Check exposure to underlying asset price movements."""
        alerts = []
        
        try:
            # Get current price of underlying asset
            current_price = await self.asset_oracle.get_price_usd(underlying_asset)
            initial_price = metadata.get('initial_underlying_price')
            
            if current_price and initial_price:
                price_change_percent = ((current_price - initial_price) / initial_price) * 100
                
                # High volatility warning
                if abs(price_change_percent) > 20:  # 20% price movement
                    position_side = metadata.get('position_side', 'both')
                    
                    # Assess impact based on position type
                    impact_severity = self._assess_price_impact_severity(
                        position_side, price_change_percent
                    )
                    
                    alerts.append(PositionAlert(
                        position_id=position.position_id,
                        position_type=self.position_type,
                        alert_type="underlying_volatility",
                        severity=impact_severity,
                        message=f"Underlying asset {underlying_asset} moved {price_change_percent:+.1f}%",
                        details={
                            "underlying_asset": underlying_asset,
                            "current_price": current_price,
                            "initial_price": initial_price,
                            "price_change_percent": price_change_percent,
                            "position_side": position_side
                        },
                        recommended_action=(
                            "Review position sizing due to high underlying volatility"
                        )
                    ))
        
        except Exception as e:
            logger.warning(f"Failed to check underlying exposure for {position.position_id}: {e}")
        
        return alerts
    
    def _assess_price_impact_severity(
        self, 
        position_side: str, 
        price_change_percent: float
    ) -> AlertSeverity:
        """Assess severity of price impact based on position side."""
        abs_change = abs(price_change_percent)
        
        # More severe for larger movements
        if abs_change > 40:
            return AlertSeverity.ERROR
        elif abs_change > 30:
            return AlertSeverity.WARNING
        else:
            return AlertSeverity.INFO
    
    async def generate_alerts(self, position, health) -> List[PositionAlert]:
        """Generate alerts for principal/yield token positions based on health assessment."""
        alerts = []
        
        try:
            # Use existing check_position_health method which already generates alerts
            position_alerts = await self.check_position_health(position)
            alerts.extend(position_alerts)
            
            # Add health-based alerts if health data is available
            if health and hasattr(health, 'risk_level'):
                if health.risk_level == RiskLevel.CRITICAL:
                    alerts.append(PositionAlert(
                        position_id=position.position_id,
                        position_type=self.position_type,
                        alert_type="health_critical",
                        severity=AlertSeverity.CRITICAL,
                        message="Position health is critical",
                        details={"health_status": health.risk_level},
                        recommended_action="Immediate attention required"
                    ))
                elif health.risk_level == RiskLevel.HIGH:
                    alerts.append(PositionAlert(
                        position_id=position.position_id,
                        position_type=self.position_type,
                        alert_type="health_high_risk",
                        severity=AlertSeverity.WARNING,
                        message="Position at high risk",
                        details={"health_status": health.risk_level},
                        recommended_action="Monitor closely"
                    ))
            
        except Exception as e:
            logger.error(f"Error generating alerts for position {position.position_id}: {e}")
            # Generate error alert
            alerts.append(PositionAlert(
                position_id=position.position_id,
                position_type=self.position_type,
                alert_type="monitoring_error",
                severity=AlertSeverity.ERROR,
                message=f"Failed to generate position alerts: {str(e)}",
                details={"error": str(e)},
                recommended_action="Check position monitoring system"
            ))
        
        return alerts


class PositionMonitor:
    """
    Comprehensive position monitoring system for various position types.
    
    This is the main monitoring engine that coordinates position-specific monitors
    and provides a unified interface for position health monitoring and alerting.
    """
    
    def __init__(
        self,
        delta_tracker: DeltaTracker,
        asset_oracle: AssetOracleBase,
        config: Optional[MonitoringConfig] = None
    ):
        """
        Initialize position monitor.
        
        Args:
            delta_tracker: DeltaTracker instance for position data
            asset_oracle: Asset oracle for price data
            config: Monitoring configuration
        """
        self.delta_tracker = delta_tracker
        self.asset_oracle = asset_oracle
        self.config = config or MonitoringConfig()
        
        # Initialize position-specific monitors
        self.monitors: Dict[PositionType, PositionMonitorBase] = {
            PositionType.ARBITRAGE: ArbitragePositionMonitor(asset_oracle, self.config),
            PositionType.YIELD_FARMING: YieldFarmingPositionMonitor(asset_oracle, self.config),
            PositionType.LENDING: LendingPositionMonitor(asset_oracle, self.config),
            PositionType.BORROWING: BorrowingPositionMonitor(asset_oracle, self.config),
            PositionType.PRINCIPAL_YIELD: PrincipalYieldPositionMonitor(self.config, asset_oracle),
        }
        
        # Monitoring state
        self.is_running = False
        self.monitoring_tasks: List[asyncio.Task] = []
        self.position_health_cache: Dict[str, PositionHealth] = {}
        self.recent_alerts: List[PositionAlert] = []
        
        # Statistics
        self.stats = {
            "positions_monitored": 0,
            "alerts_generated": 0,
            "health_checks_performed": 0,
            "last_full_scan": None,
            "average_check_time_ms": 0.0,
            "critical_alerts": 0,
            "monitoring_uptime_seconds": 0
        }
        
        self._start_time = time.time()
        
        logger.info("PositionMonitor initialized with specialized monitors for all position types")
    
    async def start_monitoring(self) -> None:
        """Start the position monitoring system."""
        if self.is_running:
            logger.warning("Position monitoring is already running")
            return
        
        self.is_running = True
        self._start_time = time.time()
        
        # Start monitoring tasks
        self.monitoring_tasks = [
            asyncio.create_task(self._main_monitoring_loop()),
            asyncio.create_task(self._high_frequency_monitoring_loop()),
            asyncio.create_task(self._daily_health_check_loop())
        ]
        
        logger.info("Position monitoring started with 3 monitoring loops")
    
    async def stop_monitoring(self) -> None:
        """Stop the position monitoring system."""
        self.is_running = False
        
        # Cancel all monitoring tasks
        for task in self.monitoring_tasks:
            task.cancel()
        
        # Wait for tasks to complete
        await asyncio.gather(*self.monitoring_tasks, return_exceptions=True)
        
        self.monitoring_tasks.clear()
        logger.info("Position monitoring stopped")
    
    async def _main_monitoring_loop(self) -> None:
        """Main monitoring loop for regular position health checks."""
        logger.info(f"Main monitoring loop started (interval: {self.config.check_interval_seconds}s)")
        
        while self.is_running:
            try:
                start_time = time.time()
                
                # Get all active positions
                positions = self.delta_tracker.get_all_positions()
                
                if positions:
                    # Get current prices for all assets
                    all_assets = set()
                    for position in positions.values():
                        all_assets.update(position.exposures.keys())
                    
                    current_prices = await self._get_current_prices(list(all_assets))
                    
                    # Check health for each position
                    alerts = []
                    for position in positions.values():
                        position_alerts = await self._check_position_comprehensive(position, current_prices)
                        alerts.extend(position_alerts)
                    
                    # Process alerts
                    if alerts:
                        await self._process_alerts(alerts)
                    
                    # Update statistics
                    check_time = (time.time() - start_time) * 1000
                    self.stats["health_checks_performed"] += len(positions)
                    self.stats["positions_monitored"] = len(positions)
                    self.stats["last_full_scan"] = datetime.now(timezone.utc)
                    self.stats["average_check_time_ms"] = (
                        (self.stats["average_check_time_ms"] + check_time) / 2
                    )
                    
                    logger.debug(f"Monitored {len(positions)} positions in {check_time:.1f}ms")
                
                await asyncio.sleep(self.config.check_interval_seconds)
                
            except Exception as e:
                logger.error(f"Error in main monitoring loop: {e}", exc_info=True)
                await asyncio.sleep(self.config.check_interval_seconds)
    
    async def _high_frequency_monitoring_loop(self) -> None:
        """High-frequency monitoring for critical positions (borrowing, arbitrage)."""
        logger.info(f"High-frequency monitoring loop started (interval: {self.config.high_frequency_interval_seconds}s)")
        
        while self.is_running:
            try:
                # Focus on high-risk position types
                high_risk_types = {PositionType.BORROWING, PositionType.ARBITRAGE}
                
                positions = self.delta_tracker.get_all_positions()
                critical_positions = {
                    pid: pos for pid, pos in positions.items()
                    if PositionType(pos.position_type) in high_risk_types
                }
                
                if critical_positions:
                    # Get prices and check critical positions
                    all_assets = set()
                    for position in critical_positions.values():
                        all_assets.update(position.exposures.keys())
                    
                    current_prices = await self._get_current_prices(list(all_assets))
                    
                    alerts = []
                    for position in critical_positions.values():
                        position_alerts = await self._check_position_comprehensive(position, current_prices)
                        # Only process critical alerts in high-frequency loop
                        critical_alerts = [
                            alert for alert in position_alerts
                            if alert.severity == AlertSeverity.CRITICAL
                        ]
                        alerts.extend(critical_alerts)
                    
                    if alerts:
                        await self._process_alerts(alerts)
                
                await asyncio.sleep(self.config.high_frequency_interval_seconds)
                
            except Exception as e:
                logger.error(f"Error in high-frequency monitoring loop: {e}", exc_info=True)
                await asyncio.sleep(self.config.high_frequency_interval_seconds)
    
    async def _daily_health_check_loop(self) -> None:
        """Daily comprehensive health check and cleanup."""
        logger.info("Daily health check loop started")
        
        while self.is_running:
            try:
                await self._perform_daily_health_check()
                await asyncio.sleep(self.config.daily_health_check_interval)
                
            except Exception as e:
                logger.error(f"Error in daily health check loop: {e}", exc_info=True)
                await asyncio.sleep(3600)  # Retry in 1 hour on error
    
    async def _check_position_comprehensive(
        self,
        position: DeltaPosition,
        current_prices: Dict[str, float]
    ) -> List[PositionAlert]:
        """Comprehensive position health check with appropriate monitor."""
        try:
            position_type = PositionType(position.position_type)
            monitor = self.monitors.get(position_type)
            
            if not monitor:
                logger.warning(f"No monitor available for position type: {position_type}")
                return []
            
            # Check position health
            health = await monitor.check_position_health(position, current_prices)
            
            # Cache health result
            self.position_health_cache[position.position_id] = health
            
            # Generate alerts
            alerts = await monitor.generate_alerts(position, health)
            
            return alerts
            
        except Exception as e:
            logger.error(f"Error checking position {position.position_id}: {e}")
            return []
    
    async def _get_current_prices(self, asset_ids: List[str]) -> Dict[str, float]:
        """Get current prices for all assets."""
        prices = {}
        
        try:
            # Use batch price fetching if available
            if hasattr(self.asset_oracle, 'get_prices_batch'):
                batch_prices = await self.asset_oracle.get_prices_batch(asset_ids)
                for asset_id, price in batch_prices.items():
                    if price is not None:
                        prices[asset_id] = price
            else:
                # Fallback to individual price fetching
                for asset_id in asset_ids:
                    price = await self.asset_oracle.get_price_usd(asset_id)
                    if price is not None:
                        prices[asset_id] = price
            
        except Exception as e:
            logger.error(f"Error fetching prices: {e}")
        
        return prices
    
    async def _process_alerts(self, alerts: List[PositionAlert]) -> None:
        """Process and handle generated alerts."""
        for alert in alerts:
            # Add to recent alerts
            self.recent_alerts.append(alert)
            
            # Keep only last 1000 alerts
            if len(self.recent_alerts) > 1000:
                self.recent_alerts = self.recent_alerts[-1000:]
            
            # Update statistics
            self.stats["alerts_generated"] += 1
            if alert.severity == AlertSeverity.CRITICAL:
                self.stats["critical_alerts"] += 1
            
            # Log alert
            log_level = {
                AlertSeverity.INFO: logging.INFO,
                AlertSeverity.WARNING: logging.WARNING,
                AlertSeverity.ERROR: logging.ERROR,
                AlertSeverity.CRITICAL: logging.CRITICAL
            }[alert.severity]
            
            logger.log(log_level, f"ALERT: {alert.message} (Position: {alert.position_id})")
            
            # Handle critical alerts immediately if configured
            if alert.severity == AlertSeverity.CRITICAL and self.config.critical_alert_immediate:
                await self._handle_critical_alert(alert)
    
    async def _handle_critical_alert(self, alert: PositionAlert) -> None:
        """Handle critical alerts that require immediate attention."""
        logger.critical(f"CRITICAL ALERT: {alert.message}")
        
        # In production, this could:
        # - Send notifications to operators
        # - Trigger automated responses if enabled
        # - Log to external monitoring systems
        # - Create incidents in incident management system
        
        # For now, just log the critical alert details
        logger.critical(f"Critical alert details: {alert.to_dict()}")
    
    async def _perform_daily_health_check(self) -> None:
        """Perform comprehensive daily health check."""
        logger.info("Performing daily comprehensive health check")
        
        try:
            # Get portfolio overview
            portfolio_snapshot = await self.delta_tracker.get_portfolio_snapshot()
            
            # Check for stale positions
            positions = self.delta_tracker.get_all_positions()
            stale_positions = []
            
            for position in positions.values():
                position_age = time.time() - position.entry_time
                
                # Different staleness thresholds by position type
                staleness_thresholds = {
                    PositionType.ARBITRAGE: 3600,      # 1 hour
                    PositionType.YIELD_FARMING: 86400 * 30,  # 30 days
                    PositionType.LENDING: 86400 * 7,   # 7 days
                    PositionType.BORROWING: 86400 * 3, # 3 days
                }
                
                position_type = PositionType(position.position_type)
                threshold = staleness_thresholds.get(position_type, 86400)  # Default 1 day
                
                if position_age > threshold:
                    stale_positions.append((position, position_age))
            
            # Generate daily health report
            health_report = {
                "total_positions": len(positions),
                "portfolio_value_usd": float(portfolio_snapshot.total_usd_long),
                "stale_positions": len(stale_positions),
                "total_alerts_24h": len([
                    alert for alert in self.recent_alerts
                    if (datetime.now(timezone.utc) - alert.timestamp).total_seconds() < 86400
                ]),
                "monitoring_uptime_hours": (time.time() - self._start_time) / 3600,
                "avg_check_time_ms": self.stats["average_check_time_ms"]
            }
            
            logger.info(f"Daily health report: {health_report}")
            
            # Clean up old alerts (keep last 24 hours)
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=24)
            self.recent_alerts = [
                alert for alert in self.recent_alerts
                if alert.timestamp > cutoff_time
            ]
            
            # Update uptime statistic
            self.stats["monitoring_uptime_seconds"] = time.time() - self._start_time
            
        except Exception as e:
            logger.error(f"Error in daily health check: {e}")
    
    async def get_position_health(self, position_id: str) -> Optional[PositionHealth]:
        """Get current health for a specific position."""
        return self.position_health_cache.get(position_id)
    
    async def get_portfolio_health_summary(self) -> Dict[str, Any]:
        """Get overall portfolio health summary."""
        positions = self.delta_tracker.get_all_positions()
        
        health_by_type = {}
        total_value = Decimal('0')
        total_at_risk = Decimal('0')
        
        for position in positions.values():
            position_type = position.position_type
            health = self.position_health_cache.get(position.position_id)
            
            if position_type not in health_by_type:
                health_by_type[position_type] = {
                    "count": 0,
                    "total_value": 0.0,
                    "avg_health_score": 0.0,
                    "critical_count": 0
                }
            
            health_by_type[position_type]["count"] += 1
            
            if health:
                health_by_type[position_type]["total_value"] += float(health.current_value_usd)
                health_by_type[position_type]["avg_health_score"] += health.health_score
                
                if health.overall_health == RiskLevel.CRITICAL:
                    health_by_type[position_type]["critical_count"] += 1
                    total_at_risk += health.current_value_usd
                
                total_value += health.current_value_usd
        
        # Calculate averages
        for stats in health_by_type.values():
            if stats["count"] > 0:
                stats["avg_health_score"] /= stats["count"]
        
        return {
            "total_positions": len(positions),
            "total_portfolio_value_usd": float(total_value),
            "total_at_risk_usd": float(total_at_risk),
            "risk_percentage": float(total_at_risk / total_value * 100) if total_value > 0 else 0,
            "health_by_position_type": health_by_type,
            "recent_alerts": len(self.recent_alerts),
            "monitoring_stats": self.get_monitoring_stats()
        }
    
    def get_monitoring_stats(self) -> Dict[str, Any]:
        """Get monitoring system statistics."""
        return {
            **self.stats,
            "is_running": self.is_running,
            "active_monitors": list(self.monitors.keys()),
            "positions_in_cache": len(self.position_health_cache),
            "recent_alerts_count": len(self.recent_alerts)
        }
    
    def get_recent_alerts(
        self,
        limit: int = 100,
        severity_filter: Optional[AlertSeverity] = None,
        position_type_filter: Optional[PositionType] = None
    ) -> List[Dict[str, Any]]:
        """Get recent alerts with optional filtering."""
        filtered_alerts = self.recent_alerts
        
        if severity_filter:
            filtered_alerts = [a for a in filtered_alerts if a.severity == severity_filter]
        
        if position_type_filter:
            filtered_alerts = [a for a in filtered_alerts if a.position_type == position_type_filter]
        
        # Sort by timestamp (newest first) and limit
        filtered_alerts.sort(key=lambda x: x.timestamp, reverse=True)
        return [alert.to_dict() for alert in filtered_alerts[:limit]]